- **compiler-compiler**: auto generate source files for an implementation from a high level description
    - Lex (generates lexical analysers), Yaac (generaters parser)
- **compiler**: reads files in one language, then translate and outputs the files in another language
- **self-hosting**: implementing a compiler in the language that it compiles for
    - you have the uncompiled compiler in the same language
    - you compile it with a compiler in a different language
    - the compiler in the same language is now compiled and can be use to compile future versions of itselfs (**bootstrapping**)

- There is a distinction between the language and the language implementation.

# Parts of a Language Implementation

- Implementation is like climbing a mountain:
    - Start off at the bottom with the source code
    - Go up each phase which transforms it to a higher level representation
    - Peak is where we understand what the code means
    - Descent is transforming the high level representation to lower-level forms for a CPU to execute

- **Scanning** (*lexing, lexical analysis*): takes in stream of characters and chunks them into **tokens** (*can be single characters, numbers, string literals, identifiers, etc.*)
    - ignores some characters like whitespaces

- **Parsing**: give the syntax a **grammar** (*compose larger expressions/statemnets from smaller ones*)
    - sequence of tokens generated by lexer => tree strucutre (**parse tree, abstract syntax tree**)
    - alerts of **syntax errors**

At this point we know the static structure of the code.

- **Static analysis**
    - **binding/resolution**: use **scope** (region of code where certain name can be used to refer to certain declaration) to connect name of each **identifer** and its definition
    - check type if the language is statically typed and report **type errors** for invalid definitions
        - if dynamically typed language, type can be checked during runtime
    - where to store the analysis:
        - back as **attributes** (extra fields in the nodes that start off unintialized) on the syntax tree
        - **lookup/symbol table** (key: identifier name, value: what the identifier refers to)

This is all **frontend** implementation. These phases can used on top of multiple **middleend/backend** implementations.
    - frontend: specified to the source language program is written in
    - backend: architecture where program will run
    - middleend: code stored in **intermediate representation (IR)** and isn't tied to source or destination forms, acts as an interface
        - able to support multiple source languages and target platforms without having to write multiple *full* compilers
        - write *one* front end for each source language that produces IR and write *one* backend for each architecture, then mix and match


- **Optimization**: retain the same semantics but implements more efficiently
    - **constant folding**:  if expression always evaluate to same value, the evaluation can be done at compile time and replace in the code

- **Code generation (code gen)**: converting code into a form that machine can run (assembly-like)
    - native code (runs the fastest, but lot of work) vs virtual instructions
    - virtual machine code (**p-code** for portable, **bytecode**): produce code for hypothetical idealized machines
        - translate by writing little mini-compiler for each target architecture that converts bytecode to native code (can reuse the rest of the compiler pipeline across all machines/chips), bytecode is used as an IR
            - farther down the pipeline the architecture-specific work is, the more of the earlier phases that can be shared
            - but optimizations work best when designed for a specific chip, so figuring out what to share is an art
        - or write a **language/process virtual machine** that can emulate the hypothetical chip supporting the virtual architecture (slower than native code because every instruction must be simulated at runtime) for simplicity and portability

- **Runtime**: can load executable (native code) or start up VM and load program (bytecode)
    - services while program is runnning (garbage collector, `instance of` tracking)
    - in fully complied language, code implementing runtime is inserted directly in executable
    - in interpreter/VM, runtime lives there

## Shortcuts and Alternate Routes

- **Single-pass compliers**: interleave parsing, analysis, and code generation to produce output code directly in parser
    - don't need to allocate syntax trees or IRs
    - restrict design of language to have no intermediate data structures for global information
    - everything you need to know to compile is in the expression itself
    - used **syntax-directed translation**: associate action that generates output code with each piece of grammar
        - when parser matches the syntax, it executes the action, building the target code one rule at a time
    
- **Tree-walk interpreters**: code executes right after parsing into an AST
    - interpreter traverses AST one branch/leaf at a time and evalutes each node as it goes
    - slow

- **Transpilers (source-to-source compiler, transcompiler)**: translates source code to another high-level language, treating it as an IR, and using existing compilation tools for the language
    - frontend straight to other language syntax, skipping the analysis
    - if languages are semantically different, then there would be more phases of a full compiler like analysis - instead of outputting machine code, it will output the target language

- **Just-in-time compilation (JIT)**: from source language or platform-independent bytecode, compile to native code for the architecture the computer supports when the program is loaded
    - sophisticated JITs insert profiling hooks into generated code to see performance critical regions and auto recompile to optimize over time

## Compilers VS Interpreters

- compilation: implementation technique that involves translating source language to another language (usually lower level)
- **compiler**: translates source code to another form but does not execute
    - user takes the output and run it themselves
- **interpreter**: execute source code immediately, runs from source

## Other
- Expressions produce a value, statements produce an effect
- Functions:
    - **argument, actual parameter**: actual value passed into function through the *argument list*
    - **parameter, formal parameter, formals**: variable that holds the value of argument inside the function, function *declaration* has *parameter list*
    - can be **first class**: real values that can be reference to, store in variables, etc.
    ```
    fun addPair(a, b) {
        return a + b;
    }

    fun identity(a) {
        return a;
    }

    print identity(addPair)(1, 2); // Prints "3".
    ```
    - since function declarations are statements, we can declare local functions (function inside another function)
    - **closures**: hold on to references to any surrounding variables that it uses
    ```
    fun returnFunction() {
        var outside = "outside";

        fun inner() { // Closure
            print outside;
        }

        return inner;
    }

    var fn = returnFunction();
    fn();
    ```
- Classes and prototypes
    - **prototype-based programming**: behavior reuse by reusing existing objects to serve as prototypes
        - prototype objects are cloned and extended
        - prototypes delegate to a new object
        - methods are stored on the prototype object
    - for classes and instances: to call a method on an instance, the instance's class is looked up and the method is found there
        - static type languages: lookup based on the static type of the instance happens at compile time (**static dispatch**)
        - dynamic type languages: lookup happens during runtime
- in statement-like expressions, you need to define what it returns
    - **implicit returns**: function automatically returns what the body evaluates to without explicit `return`