# Representing code
- simple for parser to produce, easy for interpreter to consume
- visualize precedence with a tree
    - leaf nodes are numbers
    - interior nodes are operators, branches are operands
    - *post order*: need to know the leaves first before the root
    - operator nesting

# Context Free Grammars
- regular languages are not powerful enough to handle expressions which nest arbitrarily deep
- **context free grammar (CFG)**
    - type 2 on the Chomsky hierarchy of formal grammar
    - takes set of atmoic pieces part of its **alphabet**
    - defines (infinite) set of strings that are in the grammar, each string is a sequence of the atomic pieces

- lexical vs syntactic grammar
    - lexical: alphabet consist of individual characters and strings are valid lexemes, implemented by scanner
    - syntactic: alphabet consist of token and strings are sequence of tokens (expressions), implemented by parser

### Rules
- **derivations**: string that are generated by the rules (start with the rules and then generate the string)
- **production**: the rules used to produce the strings
    - has a **head** (its name) and **body** (describes what it generates)
    - body is a list of symbols
- types of symbols:
    - **terminal**: letter from the alphabet, literal value
        - don't lead to any further moves, can only produce one symbol
    - **nonterminal**: named reference to another rule in the grammar
- can have multiple rules with the same name, can pick any of them
- **Backus-Naur form (BNF)**: way to write down the production rule
- grammar starts with the first rule
- context free grammars recursively refers back to a rule, recursive nonterminal has production on both sides are nonregular
    - regular languages can express repetition but cannot keep count of how many repetitions are needed

### Enhancing notation
- combine the rules with the same name by using a *pipe (|)*
    - `bread → "toast" | "biscuits" | "English muffin" ;`
- using parentheses for grouping, with pipes to allow series of options
    - `protein → ( "scrambled" | "poached" | "fried" ) "eggs" ;`
- use postfix `*` to allow previous symbol or group to repeat 0 or more times
- postfix `+` for 1 or more times
- `?` for 0 or 1 time